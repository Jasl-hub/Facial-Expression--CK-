# -*- coding: utf-8 -*-
"""Facial Expression-ck+.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fw9UX4w3Wd_KDN0F9qkKVWMbwPW-nQwc
"""

import numpy as np
import pandas as pd
import os
import cv2
import time
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
from pylab import rcParams
rcParams['figure.figsize'] = 20, 10

from sklearn.utils import shuffle
from sklearn.model_selection import train_test_split
from keras.utils import to_categorical
import keras
from keras import utils
from keras.models import Sequential
from keras.layers import Dense, Activation, Dropout, Flatten, Conv2D, MaxPooling2D
from keras.metrics import categorical_accuracy
from keras.models import model_from_json
from keras.callbacks import ModelCheckpoint
from keras.optimizers import *
from keras.layers import BatchNormalization
import tensorflow as tf

from google.colab import drive
drive.mount('/content/drive/MyDrive/ColabNotebooks/CK+.zip')
os.makedirs('/content/EM')

!unzip /content/drive/MyDrive/ColabNotebooks/CK+.zip -d '/content/drive/MyDrive/ColabNotebooks/CK+.zip'
#!unzip /content/drive/MyDrive/ColabNotebooks/CK+.zip -d '/content/EM'

from google.colab import drive
drive.mount('/content/drive')

print(os.listdir("/content/EM/CK+"))

# Specify the directory path containing the class folders
directory_path = '/content/EM/CK+'

# List the contents of the directory
contents = os.listdir(directory_path)

# Filter out the undesired directory (.ipynb_checkpoints)
class_folders = [item for item in contents if os.path.isdir(os.path.join(directory_path, item)) and item != '.ipynb_checkpoints']

# Print the list of class folders
print(class_folders)

"""# **Check the Order how the folders are loaded in the above cell**"""

data_path = "/content/EM/CK+"
data_dir_list = os.listdir(data_path)
img_data_list=[]
for dataset in class_folders:
    print(dataset)
    img_list=os.listdir(data_path+'/'+ dataset)
    print ('Loaded the images of dataset-'+'{}\n'.format(dataset))
    for img in img_list:
      input_img=cv2.imread(data_path + '/'+ dataset + '/'+ img )
      #input_img=cv2.cvtColor(input_img, cv2.COLOR_BGR2GRAY)
      input_img_resize=cv2.resize(input_img,(48,48))
      img_data_list.append(input_img_resize)

len(os.listdir('/content/EM/CK+/Sad'))

img_data = np.array(img_data_list)
img_data = img_data.astype('float32')
img_data = img_data/255
img_data.shape

plt.imshow(img_data[252])

"""# **Change in the order the folders are loaded above in the following cell**"""

num_classes = 6
num_of_samples = img_data.shape[0]
labels = np.ones((num_of_samples,),dtype='int64')

labels[0:74]=0 #Fear(75)
labels[75:252]=1 #Disgust(177)
labels[253:386]=2 #Angry (135)
labels[387:470]=3 #Sad (84)
labels[471:719]=4 #Surprise (249)
labels[720:926]=5 #Happy (207)

names = ['fear', 'disgust', 'angry', 'sad', 'surprise', 'happy']


def getLabel(id):
    return ['fear', 'disgust', 'angry', 'sad', 'surprise', 'happy'][id]

Y = to_categorical(labels, num_classes=num_classes)
#Shuffle the dataset
#x,y = shuffle(img_data,Y, random_state=2)

# Split the dataset
X_train, X_test, y_train, y_test = train_test_split(img_data, Y, test_size=0.15, random_state=2)
x_test=X_test

"""Model"""

input_shape=(48,48,3)

model = Sequential()
model.add(Conv2D(6, (5, 5), input_shape=input_shape, padding='same', activation = 'relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))

model.add(Conv2D(16, (5, 5), padding='same', activation = 'relu'))
model.add(Activation('relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))

model.add(Conv2D(64, (3, 3), activation = 'relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))

model.add(Flatten())
model.add(Dense(128, activation = 'relu'))
model.add(Dropout(0.5))
model.add(Dense(6, activation = 'softmax'))

model.compile(loss='categorical_crossentropy', metrics=['accuracy'],optimizer='adam')
model.summary()
model.get_config()
model.layers[0].get_config()
model.layers[0].input_shape
model.layers[0].output_shape
model.layers[0].get_weights()
np.shape(model.layers[0].get_weights()[0])
model.layers[0].trainable

from keras import callbacks
filename='model_train_new.csv'
filepath="Best-weights-my_model-{epoch:03d}-{loss:.4f}-{acc:.4f}.hdf5"

csv_log=callbacks.CSVLogger(filename, separator=',', append=False)
checkpoint = callbacks.ModelCheckpoint(filepath, monitor='val_loss', verbose=1, save_best_only=True, mode='min')
callbacks_list = [csv_log,checkpoint]
callbacks_list = [csv_log]

"""# **For checking training time only**"""

import time
from keras.callbacks import Callback

class TrainingTimeCallback(Callback):
    def on_train_begin(self, logs={}):
        self.start_time = time.time()

    def on_train_end(self, logs={}):
        end_time = time.time()
        training_time = end_time - self.start_time
        print("Training time:", training_time, "seconds")

# Create an instance of the TrainingTimeCallback
training_time_callback = TrainingTimeCallback()

# Fit the model with the training time callback
hist = model.fit(X_train, y_train, batch_size=7, epochs=100, verbose=1,
                 validation_data=(X_test, y_test), callbacks=[callbacks_list, training_time_callback])

hist = model.fit(X_train, y_train, batch_size=7, epochs=100, verbose=1, validation_data=(X_test, y_test),callbacks=callbacks_list)

score = model.evaluate(X_test, y_test, verbose=0)
print('Test Loss:', score[0])
print('Test accuracy:', score[1])

test_image = X_test[1:2]
print (test_image.shape)

import time
from keras.callbacks import Callback

class TestingTimeCallback(Callback):
    def on_test_begin(self, logs={}):
        self.start_time = time.time()

    def on_test_end(self, logs={}):
        end_time = time.time()
        testing_time = end_time - self.start_time
        print("Testing time:", testing_time, "seconds")

# Create an instance of the TestingTimeCallback
testing_time_callback = TestingTimeCallback()

# Evaluate the model with the testing time callback
score = model.evaluate(X_test, y_test, verbose=0, callbacks=[testing_time_callback])
print('Test Loss:', score[0])
print('Test accuracy:', score[1])

print(model.predict(test_image))
np.argmax(model.predict(test_image), axis=-1)
print(y_test[0:1])
res = np.argmax(model.predict(X_test[0:9]), axis=-1)
plt.figure(figsize=(10, 10))


for i in range(0,9):
   plt.subplot(330 + 1 + i)
   plt.imshow(x_test[i])
   plt.gca().get_xaxis().set_ticks([])
   plt.gca().get_yaxis().set_ticks([])
   plt.ylabel('prediction = %s' % getLabel(res[i]), fontsize=16)
# show the plot
plt.show()

# visualizing losses and accuracy
get_ipython().run_line_magic('matplotlib', 'inline')

train_loss=hist.history['loss']
val_loss=hist.history['val_loss']
train_acc=hist.history['accuracy']
val_acc=hist.history['val_accuracy']

epochs = range(len(train_acc))

plt.plot(epochs,train_loss,'r', label='Train Loss')
plt.plot(epochs,val_loss,'b', label='Value Loss')
plt.title('Train Loss vs Value Loss')
plt.legend()
plt.figure()
plt.plot(epochs,train_acc,'r', label='Train Accuracy')
plt.plot(epochs,val_acc,'b', label='Value Accuracy')
plt.title('Train Accuracy vs Value Accuracy')
plt.legend()
plt.figure()

# Import necessary libraries
import matplotlib.pyplot as plt

# Assuming you have a 'history' object containing training history (loss and accuracy)
# Replace 'hist' with your actual history object

train_loss = hist.history['loss']
val_loss = hist.history['val_loss']
train_accuracy = hist.history['accuracy']
val_accuracy = hist.history['val_accuracy']

epochs = range(len(train_loss))

# Plot training and validation loss
plt.plot(epochs, train_loss, 'r', label='Train Loss')
plt.plot(epochs, val_loss, 'b', label='Validation Loss')
plt.title('Training and Validation Loss', fontsize=18)
plt.xlabel('Number of Epochs', fontsize=16)
plt.ylabel('Loss', fontsize=16)
plt.legend()
plt.show()

# Plot training and validation accuracy
plt.plot(epochs, train_accuracy, 'r', label='Train Accuracy')
plt.plot(epochs, val_accuracy, 'b', label='Validation Accuracy')
plt.title('Training and Validation Accuracy', fontsize=18)
plt.xlabel('Epochs', fontsize=16)
plt.ylabel('Accuracy', fontsize=16)
plt.legend()
plt.show()